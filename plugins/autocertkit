#!/usr/bin/env python

# Copyright (c) Citrix Systems Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, 
# with or without modification, are permitted provided 
# that the following conditions are met:
#
# *   Redistributions of source code must retain the above 
#     copyright notice, this list of conditions and the 
#     following disclaimer.
# *   Redistributions in binary form must reproduce the above 
#     copyright notice, this list of conditions and the 
#     following disclaimer in the documentation and/or other 
#     materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
# CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
# SUCH DAMAGE.

#
# XenAPI plugin for retrieving XenStore data about a VM Guest
#

import XenAPI
import XenAPIPlugin
import subprocess
import xmlrpclib
import os, sys
import shutil
import time
import logging
import logging.handlers
import re
import base64
import tarfile
import datetime

from acktools.net import route
import acktools.log

# The biosdevname library has been moved in Tamapa,
# so we must ensure that we check that we cope with
# previous versions of XS, which use xcp.biosdevname.

try:
    from xcp.net.biosdevname import *
except ImportError:
    from xcp.biosdevname import *

from xcp.pci import *

INSTALL_DIR = '/opt/xensource/packages/files/auto-cert-kit'
LMBENCH_RESULTS_DIR = '%s/lmbench_results' % INSTALL_DIR

##################
if INSTALL_DIR not in sys.path:
    sys.path.insert(0, INSTALL_DIR)
import ssh
##################

XE = '/opt/xensource/bin/xe'
IPERF = '/usr/bin/iperf'
DROID_VM_LOC = '%s/vpx-dlvm.xva' % INSTALL_DIR
XS_INVENTORY_PATH = "/etc/xensource-inventory"
LMBENCH_CONF_LOC = "%s/config/lmbench.conf" % INSTALL_DIR
LOGROTATE_CONF_LOC = "%s/config/logrotate.conf" % INSTALL_DIR
FOR_CLEANUP = "for_cleanup"
SSH = "/usr/bin/ssh"
IP = "/sbin/ip"
ARPING = "/sbin/arping"
DHCLIENT = "/sbin/dhclient"
IFCONFIG = "/sbin/ifconfig"
ETHTOOL = "/sbin/ethtool"
KILL = "/bin/kill"
SYSCTL = "/sbin/sysctl"
CAT = "/bin/cat"
PS = "/bin/ps"
UNAME = "/bin/uname"
PGREP = "/usr/bin/pgrep"

##### Logging setup

LOG_LOC = '/var/log/auto-cert-kit-plugin.log'

log = None
def configure_logging(name):
    global log
    if log:
        acktools.log.release_log(log)
    log = acktools.log.configure_log(name, LOG_LOC, False)
    return log

configure_logging('autocertkit')

##### Exceptions

class PluginError(Exception):
    """Base Exception class for all plugin errors."""
    def __init__(self, *args):
        Exception.__init__(self, *args)

class ArgumentError(PluginError):
    """Raised when required arguments are missing, argument values are invalid,
    or incompatible arguments are given.
    """
    def __init__(self, *args):
        PluginError.__init__(self, *args)

##### Exception Decorator
def log_exceptions(func):
    def decorated(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except XenAPI.Failure, e:
            log.error('%s: XenAPI.Failure: %s', func.__name__, str(e))
            raise
        except PluginError, e:
            log.error('%s: %s: %s', func.__name__, e.__class__.__name__, str(e))
            raise
        except Exception, e:
            log.error('%s: %s: %s', func.__name__, e.__class__.__name__, str(e))
            raise
    return decorated
#############################

class Iface(object):
    """Class representing an ethernet interface"""

    required_keys = ["ip","mask","mac"]

    def __init__(self, rec):
        self.validate_rec(rec)

        for k, v in rec.iteritems():
            setattr(self, k, v)

    def validate_rec(self, rec):
        for key in self.required_keys:
            if key not in rec.keys():
                raise Exception("Error: invalid input rec '%s'" % rec)

    def to_rec(self):
        rec = {}
        for key in self.required_keys:
            rec[key] = getattr(self, key)
        return rec
        

##### Argument validation

ARGUMENT_PATTERN = re.compile(r'^[a-zA-Z0-9_:\.\-,]+$')
#Base64 allows the '=' symbol for padding - which is disallowed in shell-safe regex
#Extra symbols: '=', '/', '+'
ARGUMENT_PATTERN_BASE64 = re.compile(r'^[a-zA-Z0-9_:\.\-\=\/\+,]+$')

def validate_exists(args, key, default=None, required=True):
    """Validates that a string argument to a RPC method call is given, and
    matches the shell-safe regex, with an optional default value in case it
    does not exist.

    Returns the string.
    """
    if key in args:
        if len(args[key]) == 0:
            raise ArgumentError('Argument %r value %r is too short.' % (key, args[key]))
        if key == "vhd_blocks":
            if not ARGUMENT_PATTERN_BASE64.match(args[key]):
                raise ArgumentError('Argument %r value %r contains invalid characters for Base64.' % (key, args[key]))
        elif not ARGUMENT_PATTERN.match(args[key]):
            raise ArgumentError('Argument %r value %r contains invalid characters.' % (key, args[key]))
        if args[key][0] == '-':
            raise ArgumentError('Argument %r value %r starts with a hyphen.' % (key, args[key]))
        return args[key]
    elif not required or not default:
        return default
    else:
        raise ArgumentError('Argument %s is required.' % key)

@log_exceptions
def get_from_xensource_inventory(key):
    if os.path.isfile(XS_INVENTORY_PATH) == False:
        raise XenAPI.Failure(['NO_INVENTORY_FILE', "The XenSource Inventory file is missing."])
    fh = open(XS_INVENTORY_PATH, "r")
    data = fh.readlines()
    fh.close()
    for line in data:
        if line.find(key) > -1:
            values = line.split('\'')
            return values[1]
    return XenAPI.Failure('Error reading %s from %s' % (key, XS_INVENTORY_PATH))


##################################

ETHTOOL = "/sbin/ethtool"
IPERF = "/usr/bin/iperf"
LMBENCH = "/usr/bin/lmbench"
SSH_PUBLIC_KEY = '/root/.ssh/id_rsa.pub'
SSH_HOST_KEYS = '/root/.ssh/known_hosts'
IPERF_RPM = {"5": "iperf-2.0.4-1.el5.rf.i386.rpm", "7": "iperf-2.0.4-1.el7.rf.x86_64.rpm"}
LMBENCH_RPM = {"5": "lmbench-3.0-0.a7.1.el5.rf.i386.rpm", "7": "lmbench-3.0-0.a7.1.el7.rf.x86_64.rpm"}
IOZONE_RPM = {"5": "iozone-3.394-1.el5.rf.i386.rpm", "7": "iozone-3.424-2.el7.rf.x86_64.rpm"}
BONNIE_RPM = {"5": "bonnie++-1.94-1.el5.rf.i386.rpm", "7": "bonnie++-1.96-1.el7.rf.x86_64.rpm"}
MAKE_RPM = {"5": "make-3.81-3.el5.i386.rpm", "7": "make-3.82-21.el7.x86_64.rpm"}
SSH = "/usr/bin/ssh"
CAT = "/bin/cat"
ROUTE = "/sbin/route"

OFFLOAD_CODES = {'udp-fragmentation-offload': 'ufo',
                 'scatter-gather': 'sg',
                 'generic-segmentation-offload': 'gso',
                 'tx-checksumming': 'tx',
                 'large-receive-offload': 'lro',
                 'generic-receive-offload': 'gro',
                 'tcp-segmentation-offload': 'tso',
                 'rx-checksumming': 'rx',
                 'rx-vlan-offload': 'rxvlan',
                 'tx-vlan-offload': 'txvlan',
                 'ntuple-filters': 'ntuple',
                 'receive-hashing': 'rxhash'}
OFFLOAD_FLAGS_OFFSET = {'sg': 1,
                 'tso': 1<<16,
                 'ufo': 1<<17,
                 'gso': 1<<11,
                 'gro': 1<<14,
                 'lro': 1<<15,
                 'rxvlan': 1<<8,
                 'txvlan': 1<<7,
                 'ntuple': 1<<27,
                 'rxhash': 1<<28}


############# SSH KEY SETUP ##########################
@log_exceptions
def ssh_command(ip, username, password, cmd_str, dbg_str=None, attempts=10):
    """execute an SSH command using the parimiko library, in order
    to specify a password. Return the result to the caller."""
    if dbg_str:
        log.debug(dbg_str)

    for i in range(0, attempts):
        log.debug("Attempt %d/%d: %s" % (i, attempts, cmd_str))

        try:
            cmd = ssh.SSHCommand(ip, cmd_str, log, username, 900, password)
            return cmd.read("string").strip()
        except Exception, e:
            log.debug("Exception: %s" % str(e))
            if i + 1 == attempts:
                # If we have reached our attempts limit, and still have
                # raised an exception, we should elevate the exception.
                log.debug("Max attempt reached %d/%d" % (i + 1, attempts))
                raise e
            # Sleep before next attempt
            time.sleep(20)

    raise PluginError("An unkown error has occured!")

def install_ssh_key(session, vm_ref, username, password):
    """Install Dom0 public key in droid VM"""
    setup_public_ssh_key()
    vm_ip = wait_for_ip(session, vm_ref, 'eth0')

    fh = open(SSH_PUBLIC_KEY,'r')
    public_key = fh.read()
    fh.close()

    # Remove any host key previously installed for the specified IP address
    call = ["/bin/sed","-i","/%s/d" % vm_ip, SSH_HOST_KEYS]
    make_local_call(call)

    cmd1 = "mkdir -p /root/.ssh"
    cmd2 = "echo \"%s\"  >> /root/.ssh/authorized_keys" % public_key.strip()
    cmd_str = "%s; %s" % (cmd1, cmd2)

    log.debug("Install SSH key command string: %s" % cmd_str)
    ssh_command(vm_ip, username, password, cmd_str, "Installing SSH Key")

    # Disable hostkey checking
    call = [SSH, '-o', 'StrictHostKeyChecking=no', vm_ip]
    make_local_call(call)

    return True

def setup_public_ssh_key():
    if not os.path.exists(SSH_PUBLIC_KEY):
        call = ['/usr/bin/ssh-keygen', '-f', SSH_PUBLIC_KEY.replace('.pub',''),
                '-N', '']
        make_local_call(call)

######################################################
@log_exceptions
def inject_ssh_key(session, args):
    """Inject Dom0's public SSH key into a guest VM"""
    vm_ref = validate_exists(args, 'vm_ref')
    username = validate_exists(args, 'username')
    password = validate_exists(args, 'password')

    log.debug("Call to Inject Dom0's SSH key into %s" % vm_ref)
    install_ssh_key(session, vm_ref, username, password)
    return "OK"


@log_exceptions
def wait_for_ip(session, vm_ref, device, timeout=60):
    """Wait for an IP address to be returned (until a given timeout)"""
    
    xs_data = session.xenapi.VM.get_xenstore_data(vm_ref)
    log.debug("xenstore data: %s" % xs_data)
    key = "vm-data/control/%s/ip" % device
    if key in xs_data.keys():
        log.debug("Static IP %s found for VM %s" % (xs_data[key],
                                                    vm_ref))
        return xs_data[key]


    if not device.startswith('eth'):
        raise PluginError("Invalid device specified, it should be in the format 'ethX'")

    start = time.time()

    def should_timeout(start, timeout):
        """Method for evaluating whether a time limit has been met"""
        return time.time() - start > float(timeout)

    i = 0
    while not should_timeout(start, timeout):
        log.debug("Trying to retrieve VM IP address - Attempt %d" % i)
        ips = get_vm_ips(session, vm_ref)
        log.debug("VM %s has these %s IPs" % (vm_ref,ips))

        for k, v in ips.iteritems():
            if k == device:
                return v

        i = i + 1
        time.sleep(5)

    raise PluginError("""Timeout has been exceeded waiting for IP
                     address of VM to be returned %s """ % str(timeout))

def get_vm_ips(session, vm_ref):
    guest_metrics_ref = session.xenapi.VM.get_guest_metrics(vm_ref)
    networks = session.xenapi.VM_guest_metrics.get_networks(guest_metrics_ref)
    res = {}
    for k, v in networks.iteritems():
        if k.endswith('ip'):
            res["eth%s" % (k.replace('/ip',''))] = v
    return res

@log_exceptions
def get_local_device_linkstate(session, arg):
    """ Return current operstate of network device."""

    res = {}
    device = validate_exists(arg, 'device', None, True)

    output = make_local_call([IFCONFIG, device])['stdout']
    if 'UP' in output:
        res['operstate'] = 'up'
    else:
        res['operstate'] = 'down'
    if 'RUNNING' in output:
        res['carrier'] = 'running'
    else:
        res['carrier'] = ''

    output = make_local_call([ETHTOOL, device])['stdout']
    if 'Link detected: yes' in output:
        res['link'] = 'yes'
    elif 'Link detected: no' in output:
        res['link'] = 'no'
    else:
        res['link'] = 'unknown'

    return to_xml(res, 'linkstate')
    
def save_bugtool():
    """Saves a bugtool and returns the name"""
    log.debug("Collecting a bugtool report")
    call = ["xen-bugtool", "--yestoall"]
    info = make_local_call(call)["stdout"]
    where = info.find('/var/opt/xen/bug-report')
    bugtool_loc = ((info[where:]).split())[0]
    log.debug("Bugtool saved: %s" % bugtool_loc)
    return bugtool_loc

def run_ack_logrotate(session, args):
    """Run logrotate for ACK logs"""
    ack_logrotate_dconf = '/etc/logrotate.d/autocertkit'
    global log
    
    # This method should not log before logrotate execution to avoid os file handle error
    try:
        shutil.copyfile(LOGROTATE_CONF_LOC, ack_logrotate_dconf)
        call = ['/usr/sbin/logrotate', '-f', ack_logrotate_dconf]
        res = make_local_call(call, False)
    except Exception, e:
        return str(e)

    # Restart logging and leave results of logrotate in the log.
    log = configure_logging('autocertkit')
    if res['returncode'] != 0:
        msg = "ERR: Failed to run logrotate."
        log.error("%s: %s" % (msg, res['stderr']))
    else:
        msg = "logrotate executed successfully."
        log.debug(msg)

    return msg

############### IPERF Setup #########################

def make_local_call(call, logging=True):
    """Function wrapper for making a simple call to shell"""
    if logging:
        log.debug("make_local_call: %s" % (" ".join(call)))
    process = subprocess.Popen(call, stdout=subprocess.PIPE)
    stdout, stderr = process.communicate()
    res = {"returncode": process.returncode, "stdout": str(stdout).strip(), "stderr": str(stderr).strip()}
    if res["returncode"] != 0:
        msg = "ERR: Could not make local call %s" % ' '.join(call)
        if logging:
            log.error(msg)
            log.debug("stdout: %s" % str(stdout))
            log.debug("stderr: %s" % str(stderr))
    return res

def validate_xml_key(key):
    """Check that a key will be acceptable for an XML attribute
    there are some cases, where invalid keys will cause things
    to break when re-importing."""

    # Check that first character of key is not a number
    valid_key = re.compile(r'^[a-zA-Z].*')
    if valid_key.match(key):
        return True
    else:
        return False


def to_xml(d, t):
    s = '<?xml version="1.0"?>\n<%s' % t
    for k, v in d.iteritems():
        if not validate_xml_key(k):
            continue
        s += ' %s="%s"' % (k, xmlrpclib.escape(v))
    s += '></%s>\n' % t
    return s

def list_to_xml(l, t):
    s = '<?xml version="1.0"?><%ss>\n' % t
    for d in l:
        s += '<%s' % t
        for k, v in d.iteritems():
            if not validate_xml_key(k):
                continue
            s += ' %s="%s"' % (str(k).replace(' ','_'), xmlrpclib.escape(str(v)))
        s += '></%s>\n' % t
    s += '</%ss>' % t
    return s    

@log_exceptions
def deploy_iperf(session, args):
    """Install iPerf on a specified VM"""
    log.debug("deploy iperf plugin call")
    vm_ref = validate_exists(args, 'vm_ref')
    username = validate_exists(args, 'username')
    password = validate_exists(args, 'password')

    log.debug("validation complete")

    if not session.xenapi.VM.get_is_control_domain(vm_ref):
        # Only setup iperf if not control domain
        # - that already has iperf installed.
        i = 0
        limit = 10
        while i < limit:
            try:
                install_ssh_key(session, vm_ref, username, password)
                install_rpm(session, IPERF_RPM, vm_ref, username, password)
                break
            except:
                log.debug("Exception raised attempting to deploy iperf. Attempt %d" % i)
                time.sleep(8) #Sleep 8 seconds
                i = i + 1 #Increment counter
                if i == limit:
                    raise PluginError("Plugin Error: Cannot deploy Iperf")
                
    log.debug("iPerf installation completed")
    return "OK"

def get_pci_id(bus_id):
    """Return the PCI id for a specified bus location"""
    call = ['/sbin/lspci', '-n', '-s', bus_id]
    try:
        res = make_local_call(call)
        return res["stdout"].split()[2]
    except Exception, e:
        log.debug("Exception: %s" % str(e))

def get_pci_description(bus_id):
    """Return the PCI description for a specified bus location"""    
    log.debug("Getting decription for PCI device at bus id: %s" % bus_id)
    devices = PCIDevices()

    if bus_id not in devices.devs.keys():
        #Biosdevname returns shortened Bus IDs, so check that.
        # i.e. instead of '0000:02:00.1' --> '02:00.1'
        # remove front 5 characters.
        short_bus_id = bus_id[5:]
        if short_bus_id not in devices.devs.keys():
            raise Exception("Error: the Bus ID '%s' cannot be found in the PCI database" %
                            short_bus_id)
        else:
            #Only the short ID is found in the record, so use this.
            bus_id = short_bus_id

    dev_rec = devices.devs[bus_id]

    IDS = PCIIds.read()
    vendor = IDS.findVendor(dev_rec['vendor'])
    description = IDS.findDevice(dev_rec['vendor'], dev_rec['device'])
    return "%s %s" % (vendor, description)

def get_pci_subsystem(bus_id):
    """Return the PCI subsystem information for a specified bus location:"""
    log.debug("Getting subsystem for PCI device at bus id: %s" % bus_id)
    
    call = ['/sbin/lspci', '-nn', '-v', '-s', bus_id]
    try:
        res = make_local_call(call)
        return res["stdout"].split('\n')[1].strip()
    except Exception, e:
        log.debug("Exception: %s" % str(e))
    return ""

@log_exceptions
def create_output_package(session, args):
    """Create an output package for submission to Citrix"""

    dt = datetime.datetime.now()
    tarfile_loc = "/root/ack-submission-%s.tar.gz" % dt.strftime('%H-%M-%d-%m-%Y')

    bugtool_loc = save_bugtool()

    tar = tarfile.open(tarfile_loc, 'w:gz')

    def add_if_exists(file_loc):
        if os.path.exists(file_loc):
            tar.add(file_loc)
        else:
            log.debug("Cannot add %s to output package, does not exist" % file_loc)

    tar.add(bugtool_loc)
    tar.add("%s/test_run.conf" % INSTALL_DIR)

    add_if_exists(LMBENCH_RESULTS_DIR)
    add_if_exists("%s/iozone.log" % INSTALL_DIR)
    add_if_exists("%s/bonnie.log" % INSTALL_DIR)

    tar.add("/root/results.txt")
    tar.close()
    return tarfile_loc

def _pre_tampa_biosdevname():
    """Pre Tampa, we have to use the old biosdevname library"""
    import xcp.biosdevname
    biosdevobj = BiosDevName()
    if not biosdevobj.run():
        raise Exception("Error exceuting biosdevname XCP library.")

    type_key = 'Kernel name'
    pattern = re.compile(r'\d*:?[a-f0-9]+:[a-f0-9]+\.[a-f0-9]')
    
    return [device for device in biosdevobj.devices 
                   if (device[type_key].startswith('eth') and pattern.match(device['Bus Info']))]
    

def compat_biosdevname():
    """Return biosdevname, irrespective of system."""
    try:
        import xcp.net.biosdevname
    except ImportError:
        return _pre_tampa_biosdevname()

    devs = xcp.net.biosdevname.all_devices_all_names()
    
    devices = []
    pattern = re.compile(r'\d*:?[a-f0-9]+:[a-f0-9]+\.[a-f0-9]')

    for eth, rec in devs.iteritems():
        if pattern.match(rec['Bus Info']):
            log.debug("Found %s" % eth)
            devices.append(rec)

    return devices

@log_exceptions
def get_network_devices(session, args):
    """Return a list of network devices and their corresponding properties"""
    log.debug("Getting network devices Plugin Call")

    devices = []
    devs = compat_biosdevname()
    
    # Filter for only network devices.
    for device in devs:
        log.debug("Device: %s" % device)
        pci_id = get_pci_id(device['Bus Info'])
        device['PCI_id'] = pci_id
        log.debug("Bus Id %s" % device['Bus Info'])
        device['PCI_description'] = get_pci_description(device['Bus Info'])
        device['PCI_subsystem'] = get_pci_subsystem(device['Bus Info'])
        devices.append(device)

    return list_to_xml(devices, 'device')
    
def _get_local_storage_disk(session):
    disk_path = get_from_xensource_inventory('PRIMARY_DISK')
    log.debug("Local Storage Disk Path: %s" % disk_path)
    if os.path.islink(disk_path):
        return os.path.basename(os.readlink(disk_path))
    return os.path.basename(disk_path)

__scsi_id_regex = re.compile("([\-\d\w\/]+)\-part\d+")
def _get_local_storage_disks(session):
    """ Find all local disk """

    disks = {}
    pool = session.xenapi.pool.get_all()[0]
    host = session.xenapi.pool.get_master(pool)
    srs = session.xenapi.SR.get_all()
    for sr in srs:
        srtype = session.xenapi.SR.get_type(sr)
        if srtype not in ["ext", "lvm"]:
            continue
        for pbd in session.xenapi.SR.get_PBDs(sr):
            if session.xenapi.PBD.get_host(pbd) != host:
                continue
            dev_con = session.xenapi.PBD.get_device_config(pbd)
            if "device" not in dev_con:
                continue
            iface_path = dev_con["device"]
            m = __scsi_id_regex.match(iface_path)
            if m:
                iface_path = m.groups()[0]
            if os.path.islink(iface_path):
                disks[os.path.basename(os.readlink(iface_path))] = sr
            else:
                disks[os.path.basename(iface_path)] = sr

    return disks

__bus_id_regex = re.compile("[0-9a-fA-F]{2}\:[0-9a-fA-F]{2}\.[0-9a-fA-F]")
def _is_bus_id(bus_id):
    """ Check given bus_id is format of bus id """
    return __bus_id_regex.match(bus_id[-7:])

def _get_bus_paths(disks):
    """ Find bus path of given disk. """
    # Looking for bus path for disks
    device_path = "/sys/dev/block"
    bus_paths = {}
    for filename in os.listdir(device_path):
        fullpath = device_path + os.sep + filename
        if os.path.islink(fullpath) and os.path.basename(os.readlink(fullpath)) in disks.keys():
            bus_paths[os.readlink(fullpath)] = disks[os.path.basename(os.readlink(fullpath))]

    # paths in the list may not be the bus path but sym link to device.
    # If bus path does not include bus id, follow link to get bus path
    modified_bus_path = {}
    for bus_path, sr in bus_paths.iteritems():
        path_tokens = bus_path.split(os.sep)
        if len(path_tokens) < 5 or not _is_bus_id(path_tokens[4]):
            disk = path_tokens[-1]
            newpath = "sys/block/%s/device" % disk
            if os.path.exists(newpath) and os.path.islink(newpath):
                linked_path = os.readlink(newpath)
                if len(linked_path) < 5 or not _is_bus_id(linked_path.split(os.sep)[4]):
                    log.debug("%s or %s is not proper bus path. Failed to obtain bus path for %s" %
                        (bus_path, linked_path, disk))
                else:
                    modified_bus_path[linked_path] = sr
            else:
                log.debug("Cannot find physical device or bus path of %s. Perhaps it is a logical volume." % disk)
        else:
            modified_bus_path[bus_path] = sr

    return modified_bus_path
            

def find_dir(dirpath, dirname, max_depth=2):
    """Find a file in a given directory, recursing a limited number of times"""

    def _find(path, dname):
        """Inner function for checking a directory
        for the existance of a file"""
        for root, dirs, filenames in os.walk(path):
            log.debug("Directories: %s" % dirs)
            if dname in dirs:
                return True, os.sep.join([root, dname])
            else:
                return False, dirs

    results = []
    paths = [dirpath]

    for depth in range(max_depth):
        log.debug("Directory Depth: %d" % depth)
        
        # Take a copy of the list, so as to
        # force exiting the iteration to count depth.
        for path in list(paths):
            log.debug("Path: %s" % path)
            
            # Ensure that the path actually exists
            if os.path.exists(path):
                val, res = _find(path, dirname)
            else:
                # If the path doesn't exist, ignore it.
                continue
            # Check the result of the find.
            # If True, we found a result, so append it.
            # If False, we may have returned sub-directories.
            if val:
                results.append(res)
            else:
                # Check whether any sub directories were returned
                if res:
                    # Append sub directories to the paths list
                    # for searching the next level down.
                    for item in res:
                        paths.append("/".join([path,item]))

    return results   


@log_exceptions
def get_local_storage_devices(session, args):
    """Return a list of local storage devices and their corresponding properties"""

    # Ensure that any exceptions raised as a result of find a non-expected device 
    # passes back a failure message without halting execution.

    try:
        
        disks = _get_local_storage_disks(session)
        log.debug("Local disks found: %s" % disks)
        bus_paths = _get_bus_paths(disks)
        log.debug("Buses found: %s" % bus_paths)

        if len(bus_paths) == 0:
            return list_to_xml([{'Exception':'Cannot find Storage interface.'}], 'device')

        # Enumerate PCI Devices
        devices = PCIDevices()

        storage_devices = []
        for bus_path, sr in bus_paths.iteritems():
            
            bus_id = bus_path.split(os.sep)[4]
    
            if bus_id.startswith('0000:'):
                #We only care about the shortened id
                bus_id = bus_id[5:]
    
            # Copy dictionary record for device at specified bus location
            device = dict(devices.devs[bus_id])

            device['PCI_id'] = get_pci_id(bus_id)
            device['PCI_description'] = get_pci_description(bus_id)
            device['PCI_subsystem'] = get_pci_subsystem(bus_id)
    
            device['sr'] = sr
            driver_root_dir = "/sys/%s" % '/'.join(bus_path.split('/')[2:5])
    
            log.debug("Searching for driver sym link in '%s'" % driver_root_dir)
                   
            driver_links = find_dir(driver_root_dir, 'driver')
    
            if driver_links:
                log.debug("Found the following driver sym-links: %s" % driver_links)
    
                # Take the first link - there should only be one, but this needs
                # investigation on more bits of hardware, so let's not fail if there
                # does exist more than one link.
                driver_sym = driver_links[0]
                log.debug("Reading driver from symlink: %s" % driver_sym)
            
                # Just check the path is still there.
                if os.path.exists(driver_sym):
                    device['driver'] = os.path.basename(os.readlink(driver_sym))
            if not device in storage_devices:
                storage_devices.append(device)
    
        return list_to_xml(storage_devices, 'device')

    except Exception, e:
        log.debug("Could not get local storage info. Exception: %s" % str(e))
        return list_to_xml([{'Exception':'StorageInfoNotAvailable','Exception_Info':str(e)}], 'device')


@log_exceptions
def get_vm_ip(session, args):
    """Return an IP address for a specified VMs device"""
    vm_ref = validate_exists(args, 'vm_ref')
    device = validate_exists(args, 'device')
    return wait_for_ip(session, vm_ref, device)

@log_exceptions
def set_hw_offload(session, args):
    """Set, using ethtool, whether a specified
    hw offload is turned on or off in the devices
    driver"""
    eth_dev = validate_exists(args, 'eth_dev')
    offload_type = validate_exists(args, 'offload')
    offload_state = validate_exists(args, 'state')
    call = [ETHTOOL, '-K', eth_dev, offload_type, offload_state]
    log.debug("Ethtool Command: %s" % call)
    return make_local_call(call)["stdout"]

@log_exceptions
def get_hw_offloads_from_core(session, args):
    """Return a dictionary object specifying offload protocols by
    checking /sys/class/net/ethX """
    eth_dev = validate_exists(args, 'eth_dev')
    if eth_dev.startswith('xenbr'):
        eth_dev = eth_dev.replace('xenbr', 'eth')

    rec = {}
    flag = int(make_local_call(['cat', '/sys/class/net/%s/features' % eth_dev])['stdout'], 16)

    for offload, offset in OFFLOAD_FLAGS_OFFSET.iteritems():
        if offset & flag:
            rec[offload] = 'on'
        else:
            rec[offload] = 'off'

    return to_xml(rec, 'hw_offloads')
        
@log_exceptions
def get_hw_offloads(session, args):
    """Return a dictionary object specifying offload protocols,
    and whether they are on or off (as true or false)"""
    eth_dev = validate_exists(args, 'eth_dev')
    call = [ETHTOOL, '-k', eth_dev]
    offloads = make_local_call(call)["stdout"].split('\n')
    #Remove the item at the top of the list
    # "Offload parameters for ethX:"
    offloads.pop(0)
    rec = {}
    for line in offloads:
        arr = line.strip().split(': ')
        if len(arr) != 2:
            raise Exception("Unexpected format from ethtool -k " +
                            "has been returned. %s" % offloads)
        if arr[0] in OFFLOAD_CODES:
            rec[OFFLOAD_CODES[arr[0]]] = arr[1]
    return to_xml(rec, 'hw_offloads')

@log_exceptions
def get_network_backend(session, args):
    """Return the networking backend used by the pool"""
    fh = open('/etc/xensource/network.conf', 'r')
    backend = fh.read()
    fh.close()
    return backend.strip()

@log_exceptions
def set_network_backend_pool(session, args):
    """Set the backend used by the pool"""
    backend = validate_exists(args, 'backend')
    pool_ref = session.xenapi.pool.get_all()[0]
    master_ref = session.xenapi.pool.get_master(pool_ref)
    result = ""
    for host_ref in session.xenapi.host.get_all():
        out = session.xenapi.host.call_plugin(host_ref,
                                        'autocertkit',
                                        'set_network_backend',
                                        args)
        result += "%s: %s " % (host_ref, out)

    return result

@log_exceptions
def set_network_backend(session, args):
    """Set the backend used by the pool"""
    #Note, this requires a host reboot to become effective
    backend = validate_exists(args, 'backend')
    call = ['/opt/xensource/bin/xe-switch-network-backend', backend]
    return make_local_call(call)["stdout"]

@log_exceptions
def iperf_test(session, args):
    """Run iperf in client mode against a provided target host"""
    dst_host = validate_exists(args, 'dst')
    vm_ref = validate_exists(args, 'vm_ref')
    #params = validate_exists(args, 'params')

    this_host_uuid = get_from_xensource_inventory('INSTALLATION_UUID')
    host_ref = session.xenapi.VM.get_resident_on(vm_ref)
    if session.xenapi.host.get_uuid(host_ref) != this_host_uuid:
        return session.xenapi.host.call_plugin(host_ref, 'autocertkit',
                                                'iperf_test',
                                                args)

    window_size = validate_exists(args, 'window_size', False)
    format = validate_exists(args, 'format', False)
    buffer_length = validate_exists(args, 'buffer_length', False)
    thread_count = validate_exists(args, 'thread_count', False)

    call = [IPERF, '-y', 'csv']

    def copy(param, cmd_arg):
        if param:
            call.append(cmd_arg)
            call.append(param)

    copy(window_size, '-w')
    copy(format, '-f')
    copy(buffer_length, '-l')
    copy(thread_count, '-P')
    copy(dst_host, '-c')
    
    #Print MTU size
    call.append('-m')

    return make_local_call(call)["stdout"]
    
def parse_proc_net_dev(data):
    """Taking the contents of /proc/net/dev parse to provide a record"""
    lines = data.split('\n')

    header = lines[1]
    _, rx_cols, tx_cols = header.split("|")
    rx_cols = map(lambda x: "rx_%s" % x, rx_cols.split())
    tx_cols = map(lambda x: "tx_%s" % x, tx_cols.split())
    cols = rx_cols + tx_cols

    ifaces = {}
    for line in lines[2:]:
        if not line.find(":"):
            continue
        iface, data = line.split(":")
        iface_data = dict(zip(cols, data.split()))
        ifaces[iface.strip()] = iface_data

    return ifaces


@log_exceptions
def add_route(session, args):
    """Add a network table route to a particular VM"""
    vm_ref = validate_exists(args, 'vm_ref') 
    device = validate_exists(args, 'device')
    dest_ip = validate_exists(args, 'dest_ip')
    gw = validate_exists(args, 'gw', required=False)
    mask = validate_exists(args, 'mask', required=False)
   
    log.debug("add_route %s %s %s" % (vm_ref, device, dest_ip))

    if session.xenapi.VM.get_is_control_domain(vm_ref):

        # Check if we need to relay this call to another host
        # in the pool.

        this_host_uuid = get_from_xensource_inventory('INSTALLATION_UUID')
        host_ref = session.xenapi.VM.get_resident_on(vm_ref)
        if session.xenapi.host.get_uuid(host_ref) != this_host_uuid:
            return session.xenapi.host.call_plugin(host_ref, 'autocertkit',
                                                    'add_route',
                                                    args)

        bridge = device.replace('eth', 'xenbr')
        # Handle the case that we are dealing with Dom0
        # 1. Setup the correct routing entry in Dom0's routing table
  
        # Handle the default route case 
        if dest_ip == '0.0.0.0' and mask == '0.0.0.0' and gw:
            
            log.debug("Removing default gateway, before adding it back in")
            call = [IP, "route", "del", "default"]
            make_local_call(call)
             
            call = [IP,
                    "route",
                    "add",
                    "default",
                    "via",
                    gw,
                    "dev",
                    bridge]

        else:
            call = [IP, 
                    "route", 
                    "add", 
                    "%s/32" % dest_ip,
                    "dev", 
                    bridge]

    else:
        # Handle the case we are adding a route to a VM
        vm_m_ip = wait_for_ip(session, vm_ref, 'eth0')
        call = [SSH, 
                vm_m_ip, IP, 
                "route", 
                "add", 
                "%s/32" % dest_ip,
                "dev",
                device]

    return make_local_call(call)["stdout"]


@log_exceptions
def remove_route(session, args):
    """Remove an IP route that has been setup"""
    vm_ref = validate_exists(args, 'vm_ref')
    dest_ip = validate_exists(args, 'dest_ip')

    if session.xenapi.VM.get_is_control_domain(vm_ref):
        call = [IP, 'route', 'del', dest_ip]
        make_local_call(call)
    else:
        raise Exception("Not yet supported")

    return "OK"

@log_exceptions
def reset_arp(session, args):
    """Ensure that the switch knows which interfaces to 
    communicate with the VM over. If sharing the same subnet
    it is possible for eth0 to reply for eth1. We want to prevent
    that and ensure the switch knows which interface on the VM
    to send traffic too."""

    vm_ref = validate_exists(args, 'vm_ref')
    
    log.debug("Reset ARP for VM %s" % vm_ref)

    arp_ipv4_ignore_config = "net.ipv4.conf.all.arp_ignore=1"

    if session.xenapi.VM.get_is_control_domain(vm_ref):

        # Handle the case that we are dealing with Dom0
        call = [SYSCTL, arp_ipv4_ignore_config]
        make_local_call(call)

        # Determine the host reference
        host_ref = session.xenapi.VM.get_resident_on(vm_ref)
        pifs = session.xenapi.host.get_PIFs(host_ref)
        for pif in pifs:
            device = session.xenapi.PIF.get_device(pif)
        
            # Execute a gratuitus ARP for the device in question
            # translate device name into bridge
            bridge = device.replace('eth','xenbr')
        
            log.debug("About to send gARP out on %s" % bridge)

            bridge_dev = _get_local_device(bridge)

            if not bridge_dev.ip:
                log.debug("Error: cannot find IP for bridge %s" % bridge)
            else:
                call = [ARPING, "-c", '10', '-A', '-I', bridge, bridge_dev.ip]
                make_local_call(call)
        
    else:
        # Handle the Droid VM case
        vm_m_ip = wait_for_ip(session, vm_ref, 'eth0')
        
        # Global ARP Ignore
        cmd = "%s net.ipv4.conf.all.arp_ignore=1" % SYSCTL
        call = [SSH, vm_m_ip, cmd]
        make_local_call(call)

        vifs = session.xenapi.VM.get_VIFs(vm_ref)
        for vif in vifs:
            device_id = session.xenapi.VIF.get_device(vif)
            device = "eth%s" % device_id
       
            # Execute a gratuitus ARP for the device in question
            device_ip = wait_for_ip(session, vm_ref, device)
            call = [SSH, vm_m_ip, ARPING, "-c", '10', '-A', '-I', device, device_ip]
            make_local_call(call)

    return "OK"

def get_iface_stats(session, args):
    """Use ethtool to return a list of statistics for a given interface"""
    vm_ref = validate_exists(args, 'vm_ref')
    iface_name = validate_exists(args, 'iface')
    log.debug("Iface passed in %s" % iface_name)
    data = None
    arch = None
    
    if session.xenapi.VM.get_is_control_domain(vm_ref):
        host_ref = session.xenapi.VM.get_resident_on(vm_ref)
        this_host_uuid = get_from_xensource_inventory('INSTALLATION_UUID')

        if host_ref == session.xenapi.host.get_by_uuid(this_host_uuid):
            # Execute call locally
            call = [CAT, '/proc/net/dev']
            data = make_local_call(call)["stdout"]
            log.debug("Net Stats: %s" % data)
            call = [UNAME, '-i']
            arch = make_local_call(call)["stdout"]

        else:
            # Proxy the command to the correct host
            return session.xenapi.host.call_plugin(host_ref, 
                                                  'autocertkit', 
                                                  'get_iface_stats', 
                                                  args)
    else:
        # Dealing with a non-control domain. SSH and obtain result
        vm_m_ip = wait_for_ip(session, vm_ref, 'eth0')
        log.debug("IP address for VM '%s' is '%s'" % (vm_ref,
                                                      vm_m_ip))
    
        # Note, we rely on an SSH key being setup for this
        # droid VM.

        call = [SSH, vm_m_ip, CAT, '/proc/net/dev']     
        log.debug("About to make SSH call: %s" % call)

        data = make_local_call(call)["stdout"]

        call = [SSH, vm_m_ip, UNAME, '-i']
        log.debug("About to make SSH call: %s" % call)
        arch = make_local_call(call)["stdout"]

    if not data:
        log.error("Error: no data obtained from calls")

    if not arch:
        log.error("Error: no arch obtained from calls")

    rec = parse_proc_net_dev(data)

    if iface_name not in rec.keys():
        log.error("Error: could not find iface '%s' in stats (%s)" %
                    (iface_name, rec.keys()))

    device_stats = rec[iface_name]

    # Pass on arch info so that client can work around the wrap enforced
    # with a 32bit bytes counter.
    device_stats['arch'] = arch

    log.debug("Device Stats: %s %s" % (vm_ref, device_stats))

    return to_xml(device_stats, 'iface_stats') 

@log_exceptions
def get_host_routes(session, args):
    """Return a XML dictionary list of host routes"""
    routes = route.get_all_routes()
    route_recs = [route_obj.get_record() for route_obj in routes]
    return list_to_xml(route_recs, 'routes')

############### Host Crash #######################

@log_exceptions
def force_crash_host(session, args):
    """Forcr crash given host."""

    # Open a system request trigger file.
    fh = open('/proc/sysrq-trigger', 'w')

    # Synchronize data before crash. Ensure actions by flushing stream.
    fh.write('s')
    fh.flush()
    time.sleep(5)

    # Request crashing the host. close() will do the flushing.
    fh.write('c')
    fh.close()

    # Give some time to crash.
    time.sleep(5)

@log_exceptions
def _retrieve_crashdumps_from_xapi(session, host):
    """Search for crashdumps using xapi."""
    cds = session.xenapi.host_crashdump.get_all()
    ret = []
    for cd in cds:
        if not host == session.xenapi.host_crashdump.get_host(cd):
            continue
        ret.append({'host': host,
            'timestamp': str(session.xenapi.host_crashdump.get_timestamp(cd)),
            'size': str(session.xenapi.host_crashdump.get_size(cd)),
            'uuid': session.xenapi.host_crashdump.get_uuid(cd),
            'other-config': str(session.xenapi.host_crashdump.get_other_config(cd))
            })

    return list_to_xml(ret, 'crashdump')

CD_PATTERN = re.compile(r'\d{8}\-\d{6}\-.*')
@log_exceptions
def _retrieve_crashdumps(session, host):
    """Search for crashdumps from /var/crash."""
    CD_LOC = '/var/crash'
    if not os.path.isdir(CD_LOC):
        return list_to_xml([], 'crashdump')

    ret = []
    for apath in os.listdir(CD_LOC):
        if not CD_PATTERN.match(apath):
            continue
        size = 4096 # directory itself is size of 4096
        cdpath = CD_LOC + os.sep + apath
        for logfile in os.listdir(cdpath):
            if not os.path.isfile(cdpath + os.sep + logfile):
                continue
            size += os.path.getsize(cdpath + os.sep + logfile)
        ret.append({'host': host,
            'timestamp': str(apath),
            'size': str(size)
            })

    return list_to_xml(ret, 'crashdump')

def retrieve_crashdumps(session, args):
    """Search all crashdumps and return."""
    if not args or not 'host' in args:
        raise Exception("host is required to obtain crash dump.")

    if args and 'from_xapi' in args and args['from_xapi'] == 'True':
        return _retrieve_crashdumps_from_xapi(session, args['host'])
    return _retrieve_crashdumps(session, args['host'])


############### RPM Install #########################

@log_exceptions
def __getCentOSRelease(session, vm_ref, username, password):
    """Check CentOS Version of given vm"""
    log.debug("Searching CentOS Release string for %s" % vm_ref)
    ip_address = wait_for_ip(session, vm_ref, 'eth0')
    cmd_str = "rpm -q centos-release"
    output = ssh_command(ip_address, username, password, cmd_str)
    log.debug("Found Centos Release: %s" % output)
    return output

@log_exceptions
def install_rpm(session, rpm, vm_ref, username, password):
    """Install a predefined RPM"""

    release = __getCentOSRelease(session, vm_ref, username, password)
    if release.startswith("centos-release-"):
        ver = release[15]
    else:
        ver = "?"
    if ver not in rpm:
        raise Exception("Unknown CentOS release. Failed to install RPM.")

    ip_address = wait_for_ip(session, vm_ref, 'eth0')
    call = ['/usr/bin/scp', "-o", "StrictHostKeyChecking=no", "/opt/xensource/packages/files/auto-cert-kit/%s" % rpm[ver], 'root@%s:' % ip_address]
    log.debug(call)
    make_local_call(call)

    cmd_str = "rpm -i /root/%s --nosignature" % rpm[ver]
    log.debug(cmd_str)
    ssh_command(ip_address, username, password, cmd_str)


############### LMbench Setup #########################
@log_exceptions
def copy_lmbench_config(session, vm_ref, username, password):
    """Copy the LMbench config file to a VM"""
    if not os.path.exists(LMBENCH_CONF_LOC):
        raise Exception("LMbench config file is not present in %s" % LMBENCH_CONF_LOC)
    ip_address = wait_for_ip(session, vm_ref, 'eth0')

    # Determine where lmbench will be looking for the config
    # file, so that we can copy it to the correct place.
    cmd_str = "/usr/lib/lmbench/scripts/config"
    config_file_name = ssh_command(ip_address, username, password, cmd_str)
        
    log.debug("Deterined that VM %s needs lmbench config file named: %s" % (vm_ref, config_file_name))
    
    call = ['/usr/bin/scp',
            "-o", "StrictHostKeyChecking=no",
            LMBENCH_CONF_LOC,
            'root@%s:/usr/lib/lmbench/bin/i686-pc-linux-gnu/%s' % (ip_address, config_file_name)]
    log.debug(call)
    return make_local_call(call)["stdout"]

@log_exceptions
def deploy_lmbench(session, args):
    """Install LMbench on a VM"""
    vm_ref = validate_exists(args, 'vm_ref')
    username = validate_exists(args, 'username')
    password = validate_exists(args, 'password')

    if not session.xenapi.VM.get_is_control_domain(vm_ref):
        # Only setup iperf if not control domain
        # - that already has lmbench installed.
        i = 0
        limit = 5
        while i < limit:
            try:
                install_ssh_key(session, vm_ref, username, password)
                install_rpm(session, MAKE_RPM, vm_ref, username, password)
                install_rpm(session, LMBENCH_RPM, vm_ref, username, password)
                copy_lmbench_config(session, vm_ref, username, password)
                break
            except:
                log.debug("Exception raised attempting to deploy LMbench. Attempt %d" % i)
                time.sleep(5) #Sleep 5 seconds
                i = i + 1 #Increment counter
                if i == limit:
                    raise Exception("Cannot deploy LMbench")
                
    log.debug("LMbench installation completed")
    return "OK"

@log_exceptions
def retrieve_lmbench_logs(session, args):
    """Copy the LMbench logs back to the log dir on the master host"""
    vm_ref = validate_exists(args, 'vm_ref')
    username = validate_exists(args, 'username')
    password = validate_exists(args, 'password')
    ip_address = wait_for_ip(session, vm_ref, 'eth0')

    # Make sure the logs exists
    results_dir = '/usr/lib/lmbench/results/i686-pc-linux-gnu/'
    cmd_str = "ls %s* | wc -l" % results_dir
    log.debug(cmd_str)
    response = ssh_command(ip_address, username, password, cmd_str)

    if int(response) == 0:
        raise Exception("Couldn't find any results files in directory '%s'" % results_dir)

    # Make sure the local lmbench results dir exists
    if not os.path.exists(LMBENCH_RESULTS_DIR):
        os.makedirs(LMBENCH_RESULTS_DIR)

    # Create a directory per VM to save having to rename log files to
    # avoid overwritting other results.
    vm_lmbench_results_dir = "%s/%s" % (LMBENCH_RESULTS_DIR, vm_ref)
    os.mkdir(vm_lmbench_results_dir)

    # SCP the logs to the master host
    call = ["/usr/bin/scp", "-o", "StrictHostKeyChecking=no", 
            "root@%s:/usr/lib/lmbench/results/i686-pc-linux-gnu/*" % ip_address, 
            vm_lmbench_results_dir]

    log.debug(call)
    return make_local_call(call)["stdout"]

def lmbench_test(session):
    """Run LMbench"""
    call = [LMBENCH]
    log.debug(call)
    return make_local_call(call)["stdout"]
    

############### Iozone Setup #########################

@log_exceptions
def deploy_iozone(session, args):
    """Install Iozone on a VM"""
    vm_ref = validate_exists(args, 'vm_ref')
    username = validate_exists(args, 'username')
    password = validate_exists(args, 'password')

    if not session.xenapi.VM.get_is_control_domain(vm_ref):
        # Only setup iperf if not control domain
        # - that already has iozone installed.
        i = 0
        limit = 5
        while i < limit:
            try:
                install_ssh_key(session, vm_ref, username, password)
                install_rpm(session, IOZONE_RPM, vm_ref, username, password)
                break
            except:
                log.debug("Exception raised attempting to deploy Iozone. Attempt %d" % i)
                time.sleep(5) #Sleep 5 seconds
                i = i + 1 #Increment counter
                if i == limit:
                    raise Exception("Cannot deploy Iozone")
                
    log.debug("Iozone installation completed")
    return "OK"

@log_exceptions
def retrieve_iozone_logs(session, args):
    """Copy the Iozone logs back to the log dir on the master host"""
    vm_ref = validate_exists(args, 'vm_ref')
    username = validate_exists(args, 'username')
    password = validate_exists(args, 'password')
    ip_address = wait_for_ip(session, vm_ref, 'eth0')

    # Make sure the logs exists
    cmd_str = "test -e /root/localhost.log"
    log.debug(cmd_str)
    response = ssh_command(ip_address, username, password, cmd_str)
    if "error" in response:
        raise Exception("Cannot retrieve Iozone log from VM %s" % vm_ref)

    # SCP the logs to the master host
    call = ["/usr/bin/scp", "-o", "StrictHostKeyChecking=no", "root@%s:/root/localhost.log" % ip_address, "/opt/xensource/packages/files/auto-cert-kit/iozone.log"]
    log.debug(call)
    return make_local_call(call)["stdout"]
  

############### Bonnie++ Setup #########################

@log_exceptions
def deploy_bonnie(session, args):
    """Install Bonnie++ on a VM"""
    vm_ref = validate_exists(args, 'vm_ref')
    username = validate_exists(args, 'username')
    password = validate_exists(args, 'password')

    if not session.xenapi.VM.get_is_control_domain(vm_ref):
        # Only setup iperf if not control domain
        # - that already has bonnie++ installed.
        i = 0
        limit = 5
        while i < limit:
            try:
                install_ssh_key(session, vm_ref, username, password)
                install_rpm(session, BONNIE_RPM, vm_ref, username, password)
                vm_ip = wait_for_ip(session, vm_ref, 'eth0')
                ssh_command(vm_ip, username, password, 'mkdir -m a=rwx /root/bonnie; useradd citrix; chown citrix /root/bonnie')
                break
            except:
                log.debug("Exception raised attempting to deploy Bonnie++. Attempt %d" % i)
                time.sleep(5) #Sleep 5 seconds
                i = i + 1 #Increment counter
                if i == limit:
                    raise Exception("Cannot deploy Bonnie++")
                
    log.debug("Bonnie++ installation completed")
    return "OK"

@log_exceptions
def retrieve_bonnie_logs(session, args):
    """Copy the Bonnie++ logs back to the log dir on the master host"""
    vm_ref = validate_exists(args, 'vm_ref')
    username = validate_exists(args, 'username')
    password = validate_exists(args, 'password')
    ip_address = wait_for_ip(session, vm_ref, 'eth0')

    # Make sure the logs exists
    cmd_str = "test -e /root/localhost.log"
    log.debug(cmd_str)
    response = ssh_command(ip_address, username, password, cmd_str)
    if "error" in response:
        raise Exception("Cannot retrieve Bonnie++ log from VM %s" % vm_ref)

    # SCP the logs to the master host
    call = ["/usr/bin/scp", "-o", "StrictHostKeyChecking=no", "root@%s:/root/localhost.log" % ip_address, "/opt/xensource/packages/files/auto-cert-kit/bonnie.log"]
    log.debug(call)
    return make_local_call(call)["stdout"]
  

############### Main #########################


def handle_ipv4_static_conf(session, vm_uuid, iface, args):
    ip = validate_exists(args, 'ip')
    netmask = validate_exists(args, 'netmask')
    gw = validate_exists(args, 'gateway')

    vm_ref = session.xenapi.VM.get_by_uuid(vm_uuid)

    def add_config(key, value):
        session.xenapi.VM.add_to_xenstore_data(vm_ref, "vm-data/control/%s/%s" % (iface, key), value)

    add_config('ip', ip)
    add_config('netmask', netmask)
    add_config('gateway', gw)

    return 'OK'

def handle_ipv6_static_conf(session, vm_uuid, iface, args):
    raise Exception("IPv6 support has not been implemented for this plugin")
    return None

@log_exceptions
def droid_set_static_conf(session, args):
    """Set static network configuration for droid VM"""
    vm_uuid = validate_exists(args, 'vm_uuid')
    iface = validate_exists(args, 'iface')
    protocol = validate_exists(args, 'protocol').lower()

    if protocol not in ["ipv4","ipv6"]:
        raise Exception("Currently, static addressing is only supported for ipv4 or ivp6. (%s)" %
                        protocol)

    if protocol == "ipv4":
        return handle_ipv4_static_conf(session, vm_uuid, iface, args)
    elif protocol == "ipv6":
        return handle_ipv6_static_conf(session, vm_uuid, iface, args)
    else:
        raise Exception("Unexpected error ('%s')" % protocol)

@log_exceptions
def droid_template_import(session, args):
    """Import a xva using fully specified location"""
    #Need to encode/decode URI as it has unsafe characters for transmission.
    filename = DROID_VM_LOC
    sr_uuid = validate_exists(args, 'sr_uuid')
    call = [XE, 'vm-import', 'filename=%s' % filename, 'sr-uuid=%s' % sr_uuid]
    return make_local_call(call)["stdout"]

def process_running(process_name):
    process_list = make_local_call([PS,'aux'])["stdout"].split('\n')
    for process in process_list:
        if process_name in process:
            log.debug("Process Found: %s" % process)
            return True
    return False

def kill_processes(process_name):
    process_list = make_local_call([PGREP, process_name])["stdout"].split('\n')
    log.debug("Process List: %s" % process_list)

    pattern = "\d+"
    regex = re.compile(pattern)

    for process in process_list:
        if regex.match(process):
            make_local_call([KILL, '-9', process])

def mark_local_pif_for_cleanup(session, device):
    # Undo any transformations between bridges/devices that may
    # have taken place already
    if 'xenbr' in device:
        device = device.replace('xenbr', 'eth')

    this_host_uuid = get_from_xensource_inventory('INSTALLATION_UUID') 

    host_ref = session.xenapi.host.get_by_uuid(this_host_uuid)
    pifs = session.xenapi.host.get_PIFs(host_ref)

    for pif in pifs:
        pif_device = session.xenapi.PIF.get_device(pif)
        if pif_device == device:
            oc = session.xenapi.PIF.get_other_config(pif)
            oc[FOR_CLEANUP] = 'true'
            session.xenapi.PIF.set_other_config(pif, oc)
            return True

    raise Exception("Error: unable to find PIF for '%s' in '%s'" %
                    (device, pifs))

def run_dhclient(device):
    """Run dhclient on a specified interface. If a process already
    exists, then also take care of killing that process and starting
    dhclient up on the specified device again."""

    cmd = [DHCLIENT, "-q", "-lf", 
           "/var/lib/dhclient/dhclient-%s.leases" % device,
           "-pf", "/var/run/dhclient-%s.pid" % device, device]

    cmd_str = " ".join(cmd[1:])

    call = [PS, 'aux']
    processes = make_local_call(call)["stdout"].split('\n')

    for process in processes:
        if cmd_str in process:
            log.debug(process)
            arr = process.split()
            pid = arr[1]
            make_local_call([KILL, '-9', pid])
            time.sleep(3) # Give some time to ensure process kill

    res = make_local_call(cmd)["stdout"]

    return res

   
def _configure_local_device_ip(session, device, ip_addr, ip_netmask, mode):
    log.debug("Configure local device IP: (%s) (%s) (%s) (%s)" % (device,
                                                             ip_addr,
                                                             ip_netmask,
                                                             mode))
    # Mark the PIF as needing cleaning up
    mark_local_pif_for_cleanup(session, device) 
    
    if mode.lower() == "dhcp":
        # DHCP Case
        run_dhclient(device)

    else:
        # Static Case
        call = [IFCONFIG, device, ip_addr, 'netmask', ip_netmask]
        make_local_call(call)

    dev = _get_local_device(device)

    if not dev.ip:
        log.error("Settings Device: %s, IP: %s, Mask: %s" % (device,
                                                            dev.ip,
                                                            dev.mask))
        raise Exception("Error: failed to set IP for '%s'" % device)

    return dev

@log_exceptions
def get_local_device_info(session, args):
    device = validate_exists(args, 'device')

    # We only deal with MAC addresses on the bridge level
    # so swap out instances of eth for xenbr
    device = device.replace('eth', 'xenbr')

    log.debug("get_local_device_info for %s" % device)
    dev = _get_local_device(device)
    return to_xml(dev.to_rec(), 'devices')

@log_exceptions
def get_local_device_ip(session, args):
    device = validate_exists(args, 'device')

    # We only deal with IP addresses on the bridge level
    # so swap out instances of eth for xenbr
    device = device.replace('eth','xenbr')

    log.debug("get_local_device_ip for: %s" % device)
    dev = _get_local_device(device)
    log.debug("_get_local_device %s = %s" % (dev.device, dev.ip))
    if not dev.ip:
        raise Exception("Error: could not obtain an IP for %s" % device)
    return dev.ip

def _get_local_device(device_name):
    """Use ifconfig to get the IP address of a specified interface
    If one doesn't exist, return None"""

    log.debug("retracting device information of %s" % device_name)
    call = [IFCONFIG, device_name]
    data = make_local_call(call)["stdout"]

    log.debug("Retrieved: %s" % data)

    ip_pattern = "(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})"
    inet_match = re.search("(inet addr:|inet )(?P<ip>%s)" % ip_pattern, data)
    mask_match = re.search("(Mask:|netmask )(?P<mask>%s)" % ip_pattern, data)
    #bcast_match = re.search("(Bcast:|broadcast )(?P<broadcast>%s)" % ip_pattern, data)

    mac_pattern = "(HWaddr|ether) (?P<mac>([0-9a-fA-F]{2}\:){5}([0-9a-fA-F]{2}))"
    mac_match = re.search(mac_pattern, data)

    rec = {"device": device_name,
           "ip": None,
           "mask": None,
           "mac": None,
           }

    if inet_match:
        rec["ip"] = inet_match.group("ip")
    else:
        log.debug("Did not find ip for '%s'" % device_name)

    if mask_match:
        rec["mask"] = mask_match.group("mask")
    else:
        log.debug("Did not find netmask for '%s'" % device_name)

    if mac_match:
        rec["mac"] = mac_match.group("mac")
    else:
        log.error("Did not find MAC for '%s'" % device_name)

    iface = Iface(rec)
    log.debug("Got Iface: %s" % iface.to_rec())

    return iface


def configure_local_device_ip(session, device_name, ip_addr, ip_netmask, mode):
    """For the local Dom0, configure a bridge for the particular 
    device name in order to run a service bound to that interface"""

    log.debug("configure_local_device_ip (%s) (%s) (%s) (%s)" % (device_name,
                                                      ip_addr,
                                                      ip_netmask,
                                                      mode))

    device = device_name.lower()
   
    if 'xenbr' not in device and 'eth' in device:
        # We only want to care about allocating IPs to bridges
        device = device.replace('eth', 'xenbr')

    dev = _get_local_device(device)

    if not dev.ip or not dev.mask:
        dev = _configure_local_device_ip(session, 
                                        device, 
                                        ip_addr, 
                                        ip_netmask,
                                        mode)

    return dev

@log_exceptions
def flush_local_device(session, args):
    """flush IP of local device"""
    device = validate_exists(args, 'device')
    log.debug("Flushing IP of device: %s" % (device))

    device = device.replace('eth', 'xenbr')
    make_local_call(['ip', 'addr', 'flush', 'dev', device])

    return "OK"

@log_exceptions
def configure_local_device(session, args):  
    """Configure a local ethernet interface"""
    device = validate_exists(args, 'device')
    mode = validate_exists(args, 'mode')
    log.debug("configure_local_device (%s) (%s)" % (device, mode))

    ip_addr = None
    ip_netmask = None

    if mode == "static":
        ip_addr = validate_exists(args, 'ip_addr')
        ip_netmask = validate_exists(args, 'ip_netmask')
    else:
        if mode.lower() != "dhcp":
            raise Exception("Error: invalid 'mode' '%s'" % mode)

    dev = configure_local_device_ip(session, device, ip_addr, ip_netmask, mode)
    return "OK"
    
@log_exceptions
def start_iperf_server(session, args):
    """Start up iPerf in sever mode. This command will block - due to how iperf returns
    from the command line issued. It should be run as an Async tasks by XAPI."""

    device_name = validate_exists(args, 'device')
    mode = validate_exists(args, 'mode')

    log.debug("start_iperf_server (%s) (%s)" % (device_name, mode))

    ip_addr = None
    ip_netmask = None
    
    if mode == "static":
        ip_addr = validate_exists(args, 'ip_addr')
        ip_netmask = validate_exists(args, 'ip_netmask')
    else:
        if mode.lower() != "dhcp":
            raise Exception("Error: invalid 'mode' '%s'" % mode)
    
    dev = configure_local_device_ip(session, device_name, ip_addr, ip_netmask, mode)

    kill_processes('iperf')
     
    # Check for iperfs existence
    if not process_running(IPERF):
        log.debug("Iperf is not running - start process")
        # Disable iptables
        call = ['service', 'iptables', 'stop']
        make_local_call(call)

        #Start iperf daemon - need to ensure we don't block
        call = [IPERF, '-s', '-D', '-B', dev.ip]
        log.debug("About to start iperf server daemon (%s)" % call)
        subprocess.Popen(call, stdout=subprocess.PIPE, 
                         stderr=subprocess.PIPE, 
                         close_fds=True, bufsize=4096)

        log.debug("Call executed")

        max_attempts = 10
        attempts = 0
        #Ensure that the iperf server has actually been started
        while not process_running(IPERF) or attempts > max_attempts:
            log.debug("%d: Iperf server not yet started...waiting" % attempts)
            time.sleep(1)
            attempts = attempts + 1

        if attempts == max_attempts:
            log.debug("Failed to start the iperf server!")
            return "Error"

        log.debug("Iperf server started")
        return "OK"
    else:
        raise Exception("ERR: did not kill all iperf processes")

############# Utility function #####################

@log_exceptions
def get_kernel_version(session, args):
    """Check kernel version using uname."""
    return make_local_call(['uname', '-r'])["stdout"]

#####################################################

if __name__ == '__main__':
    XenAPIPlugin.dispatch({'get_hw_offloads': get_hw_offloads,
                           'get_hw_offloads_from_core': get_hw_offloads_from_core,
                           'set_hw_offload': set_hw_offload,
                           'iperf_test': iperf_test,
                           'lmbench_test': lmbench_test,
                           'get_vm_ip': get_vm_ip,
                           'deploy_iperf': deploy_iperf,
                           'deploy_lmbench': deploy_lmbench,
                           'deploy_iozone': deploy_iozone,
                           'deploy_bonnie': deploy_bonnie,
                           'get_network_backend': get_network_backend,
                           'set_network_backend_pool': set_network_backend_pool,
                           'set_network_backend': set_network_backend,
                           'droid_set_static_conf': droid_set_static_conf,
                           'droid_template_import': droid_template_import,
                           'retrieve_lmbench_logs': retrieve_lmbench_logs,
                           'retrieve_iozone_logs': retrieve_iozone_logs,
                           'retrieve_bonnie_logs': retrieve_bonnie_logs,
                           'get_network_devices': get_network_devices,
                           'get_local_storage_devices': get_local_storage_devices,
                           'get_iface_stats': get_iface_stats,
                           'get_host_routes': get_host_routes,
                           'get_local_device_linkstate': get_local_device_linkstate,
                           'create_output_package': create_output_package,
                           'start_iperf_server': start_iperf_server,
                           'add_route': add_route,
                           'remove_route': remove_route,
                           'reset_arp': reset_arp,
                           'flush_local_device': flush_local_device,
                           'configure_local_device': configure_local_device,
                           'get_local_device_ip': get_local_device_ip,
                           'get_local_device_info': get_local_device_info,
                           'inject_ssh_key': inject_ssh_key,
                           'get_kernel_version': get_kernel_version,
                           'run_ack_logrotate': run_ack_logrotate,
                           'retrieve_crashdumps': retrieve_crashdumps,
                           'force_crash_host': force_crash_host
                           })
